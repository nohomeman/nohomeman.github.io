<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6的迁移之路---[5]]]></title>
    <url>%2FES6%E7%9A%84%E8%BF%81%E7%A7%BB%E4%B9%8B%E8%B7%AF-5%2F</url>
    <content type="text"><![CDATA[前言对ES6中的Proxy、Class、Promise、iterator、genertaor、修饰器、import进行学习笔记 ProxyProxy(代理) 是 ES6 中新增的一个特性。Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; let obj=&#123; time:&apos;2017-03-11&apos;, name:&apos;net&apos;, _r:123 &#125;; let monitor=new Proxy(obj,&#123; // 拦截对象属性的读取 get(target,key)&#123; return target[key].replace(&apos;2017&apos;,&apos;2018&apos;) &#125;, // 拦截对象设置属性 set(target,key,value)&#123; if(key===&apos;name&apos;)&#123; return target[key]=value; &#125;else&#123; return target[key]; &#125; &#125;, // 拦截key in object操作 has(target,key)&#123; if(key===&apos;name&apos;)&#123; return target[key] &#125;else&#123; return false; &#125; &#125;, // 拦截delete deleteProperty(target,key)&#123; if(key.indexOf(&apos;_&apos;)&gt;-1)&#123; delete target[key]; return true; &#125;else&#123; return target[key] &#125; &#125;, // 拦截Object.keys,Object.getOwnPropertySymbols,Object.getOwnPropertyNames ownKeys(target)&#123; return Object.keys(target).filter(item=&gt;item!=&apos;time&apos;) &#125; &#125;) console.log(&apos;get&apos;,monitor.time);//get 2018-03-11 monitor.time=&apos;2018&apos;; monitor.name=&apos;mukewang&apos;; console.log(&apos;set&apos;,monitor.time);set 2018-03-11 console.log(&apos;has&apos;,&apos;name&apos; in monitor,&apos;time&apos; in monitor);//has true false console.log(&apos;ownKeys&apos;,Object.keys(monitor));//ownKeys [&quot;name&quot;,&apos;_r&apos;]&#125; ClassClass这个概念,作为对象的模板,通过class关键字,可以定义类。基本上,ES6的class可以看作只是一个语法糖,它的绝大部分功能,ES5都可以做到,新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&#123; // 基本定义和生成实例 class Parent&#123; constructor(name=&apos;mukewang&apos;)&#123; this.name=name; &#125; &#125; let v_parent=new Parent(&apos;v&apos;); console.log(&apos;构造函数和实例&apos;,v_parent);//构造函数和实例 Parent &#123; name: &apos;v&apos; &#125;&#125;&#123; // 继承 class Parent&#123; constructor(name=&apos;mukewang&apos;)&#123; this.name=name; &#125; &#125; class Child extends Parent&#123; &#125; console.log(&apos;继承&apos;,new Child());继承 Child &#123; name: &apos;mukewang&apos; &#125;&#125;&#123; // 继承传递参数 class Parent&#123; constructor(name=&apos;mukewang&apos;)&#123; this.name=name; &#125; &#125; class Child extends Parent&#123; constructor(name=&apos;child&apos;)&#123; super(name); this.type=&apos;child&apos;; &#125; &#125; console.log(&apos;继承传递参数&apos;,new Child(&apos;hello&apos;));//继承传递参数 Child &#123; name: &apos;hello&apos;, type: &apos;child&apos; &#125;&#125;&#123; // getter,setter class Parent&#123; constructor(name=&apos;mukewang&apos;)&#123; this.name=name; &#125; get longName()&#123; return &apos;mk&apos;+this.name &#125; set longName(value)&#123; this.name=value; &#125; &#125; let v=new Parent(); console.log(&apos;getter&apos;,v.longName);//getter mkmukewang v.longName=&apos;hello&apos;; console.log(&apos;setter&apos;,v.longName);//setter mkhello&#125;&#123; // 静态方法 class Parent&#123; constructor(name=&apos;mukewang&apos;)&#123; this.name=name; &#125; static tell()&#123; console.log(&apos;tell&apos;); &#125; &#125; Parent.tell();//test&#125;&#123; // 静态属性 class Parent&#123; constructor(name=&apos;mukewang&apos;)&#123; this.name=name; &#125; static tell()&#123; console.log(&apos;tell&apos;); &#125; &#125; Parent.type=&apos;test&apos;; console.log(&apos;静态属性&apos;,Parent.type);//静态属性 test&#125; PromisePromise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise 所谓Promise ，简单说就是一个容器，里面保存着某个未来才回结束的事件(通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise 对象的状态不受外界影响123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&#123; // 基本定义 let ajax=function(callback)&#123; console.log(&apos;执行&apos;); setTimeout(function () &#123; callback&amp;&amp;callback.call() &#125;, 1000); &#125;; ajax(function()&#123; console.log(&apos;timeout1&apos;); &#125;) // 执行 timeout1&#125;&#123; let ajax=function()&#123; console.log(&apos;执行2&apos;); return new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; resolve() &#125;, 1000); &#125;) &#125;; ajax().then(function()&#123; console.log(&apos;promise&apos;,&apos;timeout2&apos;); &#125;)//执行2 promise timeout2&#125;&#123; let ajax=function()&#123; console.log(&apos;执行3&apos;); return new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; resolve() &#125;, 1000); &#125;) &#125;; ajax() .then(function()&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; resolve() &#125;, 2000); &#125;); &#125;) .then(function()&#123; console.log(&apos;timeout3&apos;);//执行3 timeout3 &#125;)&#125;&#123; let ajax=function(num)&#123; console.log(&apos;执行4&apos;); return new Promise(function(resolve,reject)&#123; if(num&gt;5)&#123; resolve() &#125;else&#123; throw new Error(&apos;出错了&apos;) &#125; &#125;) &#125; ajax(6).then(function()&#123; console.log(&apos;log&apos;,6); &#125;).catch(function(err)&#123; console.log(&apos;catch&apos;,err); &#125;);//执行4 log6 ajax(3).then(function()&#123; console.log(&apos;log&apos;,3); &#125;).catch(function(err)&#123; console.log(&apos;catch&apos;,err); &#125;);//执行4 error&#125; 下面是一个用Promise对象实现的 Ajax 操作的例子。1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); client.send(); &#125;); return promise;&#125;;getJSON(&quot;/posts.json&quot;).then(function(json) &#123; console.log(&apos;Contents: &apos; + json);&#125;, function(error) &#123; console.error(&apos;出错了&apos;, error);&#125;); 深入理解Promise.all()我们在来看一下这段代码：123456789101112131415161718Promise.all([asyncTask(1),asyncTask(2),asyncTask(3)]).then(resultList =&gt; &#123; console.log(&apos;results:&apos;,resultList);&#125;);传入3个Promise实例：Promise.all([ new Promise(function(resolve, reject) &#123; resolve(1) &#125;), new Promise(function(resolve, reject) &#123; resolve(2) &#125;), new Promise(function(resolve, reject) &#123; resolve(3) &#125;)]).then(arr =&gt; &#123; console.log(arr) // [1, 2, 3]&#125;) Promise.race()语法和all()一样，但是返回值有所不同，race根据传入的多个Promise实例，只要有一个实例resolve或者reject，就只返回该结果，其他实例不再执行。12345678910111213Promise.race([ new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; resolve(1), 1000) &#125;), new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; resolve(2), 100) &#125;), new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; resolve(3), 10) &#125;)]).then(value =&gt; &#123; console.log(value) // 3&#125;) iterator遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。作用： 为各种数据结构，提供一个统一的、简便的访问接口使得数据结构的成员能够按某种次序排列ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费Iterator的遍历过程： 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 123456789101112&#123; let arr=[&apos;hello&apos;,&apos;world&apos;]; let map=arr[Symbol.iterator](); console.log(map.next()); console.log(map.next()); console.log(map.next());&#125;/*&#123; value: &apos;hello&apos;, done: false &#125;&#123; value: &apos;world&apos;, done: false &#125;&#123; value: undefined, done: true &#125;*/ 自定义for of 循环1234567891011121314151617181920212223242526272829303132&#123; let obj=&#123; start:[1,3,2], end:[7,9,8], [Symbol.iterator]()&#123; let self=this; let index=0; let arr=self.start.concat(self.end); let len=arr.length; return &#123; next()&#123; if(index&lt;len)&#123; return &#123; value:arr[index++], done:false &#125; &#125;else&#123; return &#123; value:arr[index++], done:true &#125; &#125; &#125; &#125; &#125; &#125; for(let key of obj)&#123; console.log(key); &#125;&#125;// 1 3 2 7 9 8 ##GeneratorGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号，二是，函数体内部使用yield语句，定义不同的内部状态。(yield语句在英语里的意思就是“产出”)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#123; // genertaor基本定义 let tell=function* ()&#123; yield &apos;a&apos;; yield &apos;b&apos;; return &apos;c&apos; &#125;; let k=tell(); console.log(k.next()); console.log(k.next()); console.log(k.next()); console.log(k.next());&#125;/*&#123; value: &apos;a&apos;, done: false &#125;&#123; value: &apos;b&apos;, done: false &#125;&#123; value: &apos;c&apos;, done: true &#125;&#123; value: undefined, done: true &#125;*/&#123; let obj=&#123;&#125;; obj[Symbol.iterator]=function* ()&#123; yield 1; yield 2; yield 3; &#125; for(let value of obj)&#123; console.log(&apos;value&apos;,value); &#125; /* value 1 value 2 value 3 */&#125;&#123; let state=function* ()&#123; while(1)&#123; yield &apos;A&apos;; yield &apos;B&apos;; yield &apos;C&apos;; &#125; &#125; let status=state(); console.log(status.next()); console.log(status.next()); console.log(status.next()); console.log(status.next()); console.log(status.next()); /* &#123; value: &apos;A&apos;, done: false &#125; &#123; value: &apos;B&apos;, done: false &#125; &#123; value: &apos;C&apos;, done: false &#125; &#123; value: &apos;A&apos;, done: false &#125; &#123; value: &apos;B&apos;, done: false &#125; */&#125; 修饰器(descriptor)decorator是ES7引入的功能，它是一个函数，用来修改类甚至于是方法的行为。12345678910111213141516171819202122232425262728293031323334&#123; let readonly=function(target,name,descriptor)&#123; descriptor.writable=false; return descriptor &#125;; class Test&#123; @readonly time()&#123; return &apos;2017-03-11&apos; &#125; &#125; let test=new Test(); // test.time=function()&#123; // console.log(&apos;reset time&apos;); // &#125;; console.log(test.time());&#125;&#123; let typename=function(target,name,descriptor)&#123; target.myname=&apos;hello&apos;; &#125; @typename class Test&#123; &#125; console.log(&apos;类修饰符&apos;,Test.myname);//&apos;hello&apos; // 第三方库修饰器的js库：core-decorators; npm install core-decorators&#125; importimport语句用于导入由另一个模块导出的绑定。创建a.js123456789101112131415let A=123;let test=function()&#123; console.log(&apos;test&apos;);&#125;class Hello&#123; test()&#123; console.log(&apos;class&apos;); &#125;&#125;export default &#123; A, test, Hello&#125; b.js1234import a from &quot;./a.ja&quot;console.log(a.A) // 123a.test()// &apos;test&apos;new a.Hello().test() // &apos;class&apos;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的迁移之路---[4]]]></title>
    <url>%2FES6%E7%9A%84%E8%BF%81%E7%A7%BB%E4%B9%8B%E8%B7%AF-4%2F</url>
    <content type="text"><![CDATA[前言对ES6中的 Symbol、Reflect、set、WeakSet、map、WeakMap SymbolSymbol是ES6新定义的一直数据类型.他表示独一无二。声明1234&#123; let a = Symbol(),b = Symbol() console.log(a === b) //false&#125; Symbol.for机制有点类似于单例模式，首先在全局中搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。和直接的Symbol就点不同了12345&#123; let a=Symbol.for(&apos;a&apos;); let b=Symbol.for(&apos;a&apos;); console.log(a===b); //true&#125; symbol类型的数据使用一般的方法是查不出其属性的。需要使用Object.getOwnPropertySymbols()或者Reflect.ownKeys()123456789101112131415161718192021222324&#123; let a1=Symbol.for(&apos;abc&apos;); let obj=&#123; [a1]:&apos;123&apos;, &apos;abc&apos;:345, &apos;c&apos;:456 &#125;; console.log(&apos;obj&apos;,obj);&#125; //obj &#123; abc: 345, c: 456, [Symbol(abc)]: &apos;123&apos; &#125; for(let [key,value] of Object.entries(obj))&#123; console.log(&apos;let of&apos;,key,value);//let of abc 345 // let of c 456 &#125; Object.getOwnPropertySymbols(obj).forEach(function(item)&#123; console.log(obj[item]); // 123 &#125;) Reflect.ownKeys(obj).forEach(function(item)&#123; console.log(&apos;ownkeys&apos;,item,obj[item]); &#125;) /* ownkeys abc 345 ownkeys c 456 ownkeys Symbol(abc) 123 */ Reflect对象在上面提到的一个Reflect这个对象,多数Reflect方法原生的Object已经重新实现了. 为什么要使用Reflect123456789101112131415复制代码try &#123; Object.defineProperty(obj, name, desc); // property defined successfully&#125; catch (e) &#123; // possible failure (and might accidentally catch the wrong exception)&#125;//执行成功会返回obj， 以及其它原因导致的错误if (Reflect.defineProperty(obj, name, desc)) &#123; // success&#125; else &#123; // failure&#125;//只会返回false或者true来表示对象的属性是否设置上了 在ES5中这样判断：name in obj ； 或者删除一个属性 ：delete obj[name], 虽然这些很好用， 很简短， 很明确， 但是要使用的时候也要封装成一个类；有了Reflect， 它帮你封装好了， Reflect.has(obj, name), Reflect.deleteProperty(obj, name); Reflect.ownKeys()方法的使用：Reflect.ownKeys， Object可没有ownKeys方法, Reflect.ownKeysz他的作用是返回对象的keys;12345678复制代码console.log(Reflect.ownKeys(&#123;&quot;a&quot;:0,&quot;b&quot;:1,&quot;c&quot;:2,&quot;d&quot;:3&#125;)); //输出 ：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]console.log(Reflect.ownKeys([])); // [&quot;length&quot;]var sym = Symbol.for(&quot;comet&quot;);var sym2 = Symbol.for(&quot;meteor&quot;);var obj = &#123;[sym]: 0, &quot;str&quot;: 0, &quot;773&quot;: 0, &quot;0&quot;: 0, [sym2]: 0, &quot;-1&quot;: 0, &quot;8&quot;: 0, &quot;second str&quot;: 0&#125;;Reflect.ownKeys(obj); //输出：/ [ &quot;0&quot;, &quot;8&quot;, &quot;773&quot;, &quot;str&quot;, &quot;-1&quot;, &quot;second str&quot;, Symbol(comet), Symbol(meteor) ] SetES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#123; let list = new Set(); list.add(5); list.add(7); console.log(&apos;size&apos;,list.size);//2&#125;&#123; let arr = [1,2,3,4,5]; let list = new Set(arr); console.log(&apos;size&apos;,list.size);//5&#125;&#123; let list = new Set(); list.add(1); list.add(2); list.add(1); console.log(&apos;list&apos;,list);//list Set &#123; 1, 2 &#125; let arr=[1,2,3,1,&apos;2&apos;];//unique Set &#123; 1, 2, 3, &apos;2&apos; &#125; let list2=new Set(arr); console.log(&apos;unique&apos;,list2);&#125;&#123; let arr=[&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;]; let list=new Set(arr); console.log(&apos;has&apos;,list.has(&apos;add&apos;));//has true console.log(&apos;delete&apos;,list.delete(&apos;add&apos;),list);//delete true Set &#123; &apos;delete&apos;, &apos;clear&apos;, &apos;has&apos; &#125; list.clear(); console.log(&apos;list&apos;,list);//list Set &#123;&#125;&#125;&#123; let arr=[&apos;add&apos;,&apos;delete&apos;,&apos;clear&apos;,&apos;has&apos;]; let list=new Set(arr); for(let key of list.keys())&#123; console.log(&apos;keys&apos;,key); &#125; /* keys add keys delete keys clear keys has */ for(let value of list.values())&#123; console.log(&apos;value&apos;,value); &#125; /* value add value delete value clear value has */ for(let [key,value] of list.entries())&#123; console.log(&apos;entries&apos;,key,value); &#125; /* entries add add entries delete delete entries clear clear entries has has */ list.forEach(function(item)&#123;console.log(item);&#125;) /* add delete clear has */&#125; Set实现并集，交集，差集123456789101112let set1 = new Set([1,2,3,4,5,6]);let set2 = new Set([4,5,6,7,8,9]);//并集let union = new Set([...set1,...set2]);//[1,2,3,4,5,6,7,8,9]//交集let intersect = new Set([...set1].filter(x =&gt; b.has(s)));//[4,5,6]//差集let intersect = new Set([...set1].filter(x =&gt; !b.has(s)));//[1,2,3,4] Map123456789101112131415&#123; let map = new Map(); let arr=[&apos;123&apos;]; map.set(arr,456); console.log(&apos;map&apos;,map,map.get(arr));//map Map &#123; [ &apos;123&apos; ] =&gt; 456 &#125; 456&#125;&#123; let map = new Map([[&apos;a&apos;,123],[&apos;b&apos;,456]]); console.log(&apos;map args&apos;,map);//map args Map &#123; &apos;a&apos; =&gt; 123, &apos;b&apos; =&gt; 456 &#125; console.log(&apos;size&apos;,map.size);//size 2 console.log(&apos;delete&apos;,map.delete(&apos;a&apos;),map);//delete true Map &#123; &apos;b&apos; =&gt; 456 &#125; console.log(&apos;clear&apos;,map.clear(),map);clear undefined Map &#123;&#125;&#125; WeakMap、WeakSet他们对值的引用都是不计入垃圾回收机制的，所以名字里才会有一个weak，表示这个弱引用下面以 WeakMap 为例，看看它是怎么解决内存泄漏的1234const wm = new WeakMap();const element = document.getElementById(&apos;example&apos;);vm.set(element,&apos;something&apos;);vm.get(element); 先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的迁移之路---[3]]]></title>
    <url>%2FES6%E7%9A%84%E8%BF%81%E7%A7%BB%E4%B9%8B%E8%B7%AF-3%2F</url>
    <content type="text"><![CDATA[前言接着数据类型这块Array、Object、function ArrayArray.of()方法基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。1234567&#123; let arr = Array.of(3,4,7,9,11); console.log(&apos;arr=&apos;,arr); let empty=Array.of(); console.log(&apos;empty&apos;,empty);&#125; Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。12345678910111213&#123; let arrayLike = &#123; 0: &apos;tom&apos;, 1: &apos;65&apos;, 2: &apos;男&apos;, 3: [&apos;jane&apos;,&apos;john&apos;,&apos;Mary&apos;], &apos;length&apos;: 4&#125;let arr = Array.from(arrayLike)console.log(arr) // [&apos;tom&apos;,&apos;65&apos;,&apos;男&apos;,[&apos;jane&apos;,&apos;john&apos;,&apos;Mary&apos;]] console.log(Array.from([1,3,5],function(item)&#123;return item*2&#125;));//[ 2, 6, 10 ]&#125; Array.fill()有三个参数分别是覆盖的值，以及覆盖范围1234&#123; console.log(&apos;fill-7&apos;,[1,&apos;a&apos;,undefined].fill(7));//fill-7 [ 7, 7, 7 ] console.log(&apos;fill,pos&apos;,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(7,1,3));//fill,pos [ &apos;a&apos;, 7, 7 ]&#125; 获取Array的相关数据1234567891011&#123; for(let index of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].keys())&#123; console.log(index); &#125;//0;1;2 for(let value of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].values())&#123; console.log(value);//1;c;ks &#125; for(let [index,value] of [&apos;1&apos;,&apos;c&apos;,&apos;ks&apos;].entries())&#123; console.log(index,value);0,1;1,c;2,ks &#125;&#125; 查找Array数据的api1234567891011121314//Array.prototype.copyWithin(target, start = 0, end = this.length)&#123; console.log([1,2,3,4,5].copyWithin(0,3,4));//[4,2,3,4,5]&#125;&#123; console.log([1,2,3,4,5,6].find(function(item)&#123;return item&gt;3&#125;));//4 console.log([1,2,3,4,5,6].findIndex(function(item)&#123;return item&gt;3&#125;));//3&#125;&#123; console.log(&apos;number&apos;,[1,2,NaN].includes(1));//true console.log(&apos;number&apos;,[1,2,NaN].includes(NaN));//true&#125; Object在说Object新增了哪些api之前我先说说，es6的一些简易写法1234567891011121314151617181920212223242526&#123; // 简洁表示法 let o=1; let k=2; let es5=&#123; o:o, k:k &#125;; let es6=&#123; o, k &#125;; console.log(es5,es6); let es5_method=&#123; hello:function()&#123; console.log(&apos;hello&apos;); &#125; &#125;; let es6_method=&#123; hello()&#123; console.log(&apos;hello&apos;); &#125; &#125;; console.log(es5_method.hello(),es6_method.hello());&#125; 接下来是属性表达式123456789101112131415&#123; // 属性表达式 let a=&apos;b&apos;; let es5_obj=&#123; a:&apos;c&apos;, b:&apos;c&apos; &#125;; let es6_obj=&#123; [a]:&apos;c&apos; &#125; console.log(es5_obj,es6_obj);//&#123; a: &apos;c&apos;, b: &apos;c&apos; &#125; &#123; b: &apos;c&apos; &#125;&#125; 新增的api123456789101112&#123; // 新增API console.log(&apos;字符串&apos;,Object.is(&apos;abc&apos;,&apos;abc&apos;),&apos;abc&apos;===&apos;abc&apos;);//字符串 true true console.log(&apos;数组&apos;,Object.is([],[]),[]===[]);//数组 false false console.log(&apos;拷贝&apos;,Object.assign(&#123;a:&apos;a&apos;&#125;,&#123;b:&apos;b&apos;&#125;));//拷贝 &#123; a: &apos;a&apos;, b: &apos;b&apos; &#125; let test=&#123;k:123,o:456&#125;; for(let [key,value] of Object.entries(test))&#123; console.log([key,value]);//[ &apos;k&apos;, 123 ][ &apos;o&apos;, 456 ] &#125;&#125; 扩展运算符reset写法1234&#123; let &#123;a,b,...c&#125;=&#123;a:&apos;test&apos;,b:&apos;kill&apos;,c:&apos;ddd&apos;,d:&apos;ccc&apos;&#125;; console.log(a,b,c);//test ,kill, &#123; c: &apos;ddd&apos;, d: &apos;ccc&apos; &#125;&#125; function函数默认值1234567891011121314&#123; function test(x, y = &apos;world&apos;)&#123; console.log(&apos;默认值&apos;,x,y);//默认值 hello world &#125; test(&apos;hello&apos;); test(&apos;hello&apos;,&apos;kill&apos;);//默认值 hello kill&#125;&#123; let x=&apos;test&apos;; function test2(x,y=x)&#123; console.log(&apos;作用域&apos;,x,y); &#125; test2(&apos;kill&apos;);//作用域 kill kill&#125; 函数reset参数12345678910111213&#123; function test3(...arg)&#123; for(let v of arg)&#123; console.log(&apos;rest&apos;,v); &#125; &#125; test3(1,2,3,4,&apos;a&apos;);//rest 1 rest 2 rest 3 rest 4 rest a&#125;&#123; console.log(...[1,2,4]);//124 console.log(&apos;a&apos;,...[1,2,4]);//a123&#125; 箭头函数123456&#123; let arrow = v =&gt; v*2; let arrow2 = () =&gt; 5; console.log(&apos;arrow&apos;,arrow(3));//arrow 6 console.log(arrow2());// 5&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的迁移之路---[2]]]></title>
    <url>%2FES6%E7%9A%84%E8%BF%81%E7%A7%BB%E4%B9%8B%E8%B7%AF-2%2F</url>
    <content type="text"><![CDATA[前言接着写没写完的！今天主要针对的是数据类型的迁移、这一篇主要针对Number、String Number二进制和八进制的新的表示方法 二进制以’0b’或者’0B’开头八进制以’0o’或者’0O’开头 123450b111110111 === 503 // true0o767 === 503 // true//二进制和八进制转化为十进制Number(&apos;0b111&apos;) // 7Number(&apos;0o10&apos;) // 8 Number对象新增的方法Number.isFinite()检测一个数值是不是有限的,只有数字且是有限的才会返回true,否则一律是falseNumber.isNaN(),检测一个数值是不是NaN,只有数字且是NaN的时候才会返回true,否则一律false 1234567&#123; Number.isFinite(123); // true Number.isFinite(&quot;123&quot;); // false Number.isFinite(&quot;sd&quot;); // false Number.isNaN(NaN); //true Number.isNaN(123); //false&#125; Number.parseInt(),Number.parseFloat()将全局的parseInt和parseFloat移植到Number对象上,行为不变Number.isInteger(),判断数值是不是整数123456// 3.0000000000000002达到了小数点后16个10进制位数,转换为2进制就超出了2^53,所以最后一个2被忽略了,仍然被认为是整数Number.isInteger(3.0000000000000002) // trueconsole.log(&apos;25&apos;,Number.isInteger(25));// trueconsole.log(&apos;25.0&apos;,Number.isInteger(25.0));//trueconsole.log(&apos;25.1&apos;,Number.isInteger(25.1));//falseconsole.log(&apos;25.1&apos;,Number.isInteger(&apos;25&apos;));//false Number.EPSILON,是一个常量,表示1和大于1的最小浮点数的差 1Number.EPSILON === Math.pow(2,-52); // true Number.isSafeInteger(),判断一个整数是不是在常量Number.MIN_SAFE_INTEGER和Number.MAX_SAFE_INTEGER之间,包括2端12345&#123; console.log(Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER); console.log(&apos;10&apos;,Number.isSafeInteger(10));//true console.log(&apos;a&apos;,Number.isSafeInteger(&apos;a&apos;));//false&#125; Math对象的拓展Math.trunc()方法用于去除一个数的小数部分，返回整数部分。1234&#123; console.log(4.1,Math.trunc(4.1));//4 console.log(4.9,Math.trunc(4.9));//4&#125; 注意参数为非数值时，Math.trunc()方法会先用Number()将其转换为数值，若无法获取数值的整数部分，比如字符串或NaN或空值等，会返回NaN.1console.log(Math.trunc(NaN),Math.trunc(&apos;foo&apos;),Math.trunc())//NaN,NaN,NaN Math.sign()方法用来判断一个数到底是正数、负数还是0 (1)参数为正数返回+1(2)参数为负数返回-1(3)参数为0返回0(4)参数为-0返回-0(5)其他值返回NaN 12345678console.log( Math.sign(-5), Math.sign(5), Math.sign(0), Math.sign(NaN), Math.sign(&apos;aaa&apos;), Math.sign() )//-1,1,0,NaN,NaN,NaN Math.cbrt()方法用于计算一个数的立方根 1234&#123; console.log(&apos;-1&apos;,Math.cbrt(-1));-1 console.log(&apos;8&apos;,Math.cbrt(8));2&#125; Math.hypot()方法返回所有参数的平方和的平方根。1234567Math.hypot(3,4)//5Math.hypot(3,4,5)//7.07106Math.hypot()//0Math.hypot(NaN)//NaNMath.hypot(3,4,&apos;foo&apos;)//NaNMath.hypot(3,4,&apos;5&apos;)//7.07106Math.hypot(-3)//3 注意Math.hypot()会把非数值参数转换为数值，若有一个参数不能转为数值就返回NaN. ES6新增了6个三角函数方法. (1)Math.sinh(x) 返回x的双曲正弦(2)Math.cosh(x) 返回x的双曲余弦(3)Math.tanh(x) 返回x的双曲正切(4)Math.asinh(x) 返回x的反双曲正弦(5)Math.acosh(x) 返回x的反双曲余切(6)Math.atanh(x) 返回x的反双曲正切 ES7增加了一个指数运算符**,可以与等号结合 2**3//8let a=2;a**=2;//等价于a=a**a; String类型includes(), startsWith(), endsWith()从字面就可以明白，一个是看是否包含子串，一个是是否以子串开头，一个是是否以子串结尾。12345let s = &apos;Hello world!&apos;;s.startsWith(&apos;Hello&apos;) // trues.endsWith(&apos;!&apos;) // trues.includes(&apos;o&apos;) // true includes()比indexOf()的优势在于，indexOf()的返回结果不是布尔值，须与-1对比，不够直观。这三个方法都支持第二个参数，表示从哪里开始检索。 其中，includes()和startsWith()的默认值是0，表示检索范围是参数值检索到末尾，很简单不多说。 endsWith()很特殊，它第二个参数的默认值是字符串总长度值，表示检索范围是从开头检索到这个值。12345let s = &apos;Hello world!&apos;;s.includes(&apos;Hello&apos;, 6) // false 从左起第6位到末尾的范围内检索，结果是没找到s.startsWith(&apos;world&apos;, 6) // true 从左起第6位到末尾，看看是不是以world开头，结果是s.endsWith(&apos;Hello&apos;, 8) // false 从开头找到第8位，看看是不是以Hello结束，结果不是 repeat()表示重复多少次。 如果参数是正小数，会取整。如果参数是负数，会报错。如果参数是0，会得到空串。如果参数是字符串、布尔型或其他类型，会先换算成整数。1234&#123; let str=&quot;abc&quot;; console.log(str.repeat(2));//abcabc&#125; padStart()，padEnd()这两个是ES8（也就是2017）新增方法用于在开头补全字符和在末尾补全字符，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。1234&#123; console.log(&apos;1&apos;.padStart(2,&apos;0&apos;));//01 console.log(&apos;1&apos;.padEnd(2,&apos;0&apos;));//10&#125; 重点模板字符串123456789101112131415&#123; let name=&quot;list&quot;; let info=&quot;hello world&quot;; let m=`i am $&#123;name&#125;,$&#123;info&#125;`; console.log(m);//i am list,hellow world let user=&#123; name:&apos;list&apos;, info:&apos;hello world&apos; &#125;; console.log(abc`i am $&#123;user.name&#125;,$&#123;user.info&#125;`);//abci am list,hellow world console.log(String.raw`Hi\n$&#123;1+2&#125;`);//Hi\n3 console.log(`Hi\n$&#123;1+2&#125;`);//h(换行了)3&#125; 我们可以看出，现在这种写法更加的友好了。比如有一段HTML是：1234567&lt;div class=&quot;page&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;a target=&quot;_blank&quot; class=&quot;news-link&quot; href=&quot;/news/92199/nodemon-1-14-8&quot;&gt;Nodemon v1.14.8 发布&lt;/a&gt; &lt;span class=&quot;box-fr news-date&quot;&gt;01/07&lt;/span&gt; &lt;/div&gt; ... 重复若干个div.box&lt;/div&gt; 我就可以设一个返回最终HTML的函数，这个函数使用了ES6的简写方法1234567891011121314151617const createTmpl = boxes =&gt; `&lt;div class=&quot;page&quot;&gt; $&#123;boxes.map(box =&gt; ` &lt;div class=&quot;box&quot;&gt; &lt;a target=&quot;_blank&quot; class=&quot;news-link&quot; href=&quot;$&#123;box.href&#125;&quot;&gt;$&#123;box.title&#125;&lt;/a&gt; &lt;span class=&quot;box-fr news-date&quot;&gt;$&#123;box.date&#125;&lt;/span&gt; &lt;/div&gt; `).join(&apos;&apos;)&#125;&lt;/div&gt;`;let boxdata = [ &#123;href: &quot;http://...1&quot;, title: &quot;biaoti1&quot;, date: &quot;01/08&quot;&#125;, &#123;href: &quot;http://...2&quot;, title: &quot;biaoti2&quot;, date: &quot;02/08&quot;&#125;,];createTmpl(boxdata); 然后传入数据，调用函数，得到：123456789101112131415&quot;&lt;div class=&quot;page&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;a target=&quot;_blank&quot; class=&quot;news-link&quot; href=&quot;http://...1&quot;&gt;biaoti1&lt;/a&gt; &lt;span class=&quot;box-fr news-date&quot;&gt;01/08&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;a target=&quot;_blank&quot; class=&quot;news-link&quot; href=&quot;http://...2&quot;&gt;biaoti2&lt;/a&gt; &lt;span class=&quot;box-fr news-date&quot;&gt;02/08&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&quot; 今天就写到这里吧，下次给大家带来Array、Object、Function的变化]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习之浅谈函数柯里化(Currying)]]></title>
    <url>%2FJavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%85%E8%B0%88%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96-Currying%2F</url>
    <content type="text"><![CDATA[前言最近是想着坚实一下自己JS的基础，所以想着看看原生的知识。 准备在这里先说说什么是函数柯里化。 什么是函数柯里化 在一个函数中首先填充几个参数(然后再返回一个新函数)的技术称为柯里化(Currying)。(来自《JavaScript忍者秘籍》一书中) 开始这里有两个例子可以帮助理解！最简单的加法函数123456//函数定义function add(x,y)&#123; return x + y;&#125;//函数调用add(3,4);//5 如果采用柯里化是怎样将接受两个参数的函数变成接受单一参数的函数呢，其实很简单如下：12345678//函数表达式定义var add = function(x)&#123; return function(y)&#123; return x + y; &#125;&#125;;//函数调用add(3)(4); 其实实质利用的就是闭包的概念。 作用本质上讲柯里化(Currying)只是一个理论模型，柯里化所要表达是:如果你固定某些参数，你将得到接受余下参数的一个函数,所以对于有两个变量的函数y^x，如果固定了y=2，则得到有一个变量的函数2^x。这就是求值策略中的部分求值策略。柯里化(Currying)具有：延迟计算、参数复用、动态生成函数的作用。 JS中bind()与函数柯里化其实在实际使用中使用最多的一个柯里化的例子就是Function.prototype.bind()函数，我们也一并给出一个较为简单的Function.prototype.bind()函数的实现方式。 绑定函数bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。不同于call和apply只是单纯地设置this的值后传参，它还会将所有传入bind()方法中的实参（第一个参数之后的参数）与this一起绑定。 123456789101112131415161718192021222324252627282930313233343536373839//《JS权威指南》原文的例子var sum = function(x,y) &#123; return x + y &#125;;var succ = sum.bind(null, 1); //让this指向null，其后的实参也会作为实参传入被绑定的函数sumsucc(2); // =&gt; 3: 可以看到1绑定到了sum函数中的x//传入bind中的实参都会绑定到原函数的形参function func(a,b,c,d)&#123;...&#125; //func的length为4var after = func.bind(null,1,2); //这里输入了两个实参（1，2）绑定到了func函数的a，bconsole.log(after.length); //after的length为2//当bind()所返回的函数用作构造函数的时候， 传入bind()的this将被忽略，实参会全部传入原函数function original(x)&#123; this.a = 1; this.b = function()&#123;return this.a + x&#125;&#125;var obj=&#123; a = 10&#125;var newObj = new(original.bind(obj, 2)); //传入了一个实参2console.log(newObj.a); //输出1, 说明返回的函数用作构造函数时obj(this的值)被忽略了console.log(newObj.b()); //输出3 ，说明传入的实参2传入了原函数original简单的`Function.prototype.bind()`函数的实现方式。Function.prototype.bind = function()&#123; var fn = this; var args = Array.prototye.slice.call(arguments); var context = args.shift(); return function()&#123; return fn.apply(context, args.concat(Array.prototype.slice.call(arguments))); &#125;;&#125;; 实战演练一道关于闭包和函数的柯里化方面的编程题目编程题目的要求如下，完成plus函数，通过全部的测试用例。 12345&apos;use strict&apos;;function plus(n)&#123;&#125;module.exports = plus 测试用例如下 1234567891011121314151617181920&apos;use strict&apos;;var assert = require(&apos;assert&apos;)var plus = require(&apos;../lib/assign-4&apos;)describe(&apos;闭包应用&apos;,function()&#123; it(&apos;plus(0) === 0&apos;,function()&#123; assert.equal(0,plus(0).toString()) &#125;) it(&apos;plus(1)(1)(2)(3)(5) === 12&apos;,function()&#123; assert.equal(12,plus(1)(1)(2)(3)(5).toString()) &#125;) it(&apos;plus(1)(4)(2)(3) === 10&apos;,function()&#123; assert.equal(10,plus(1)(4)(2)(3).toString()) &#125;) it(&apos;方法引用&apos;,function()&#123; var plus2 = plus(1)(1) assert.equal(12,plus2(1)(4)(2)(3).toString()) &#125;)&#125;) 根据测试用例我们可以发现，plus函数的要求就是接受单一函数，例如： 1plus(1)(4)(2)(3).toString() 但是与柯里化不同之处在于，柯里化返回的一个新函数。我们观察其实最后的求值是通过toString函数得到的，那么我们就很容易想到，我们可以给返回的函数增加一个toString属性就可以了。答案如下： 12345678910111213141516171819202122&apos;use strict&apos;;function plus(num) &#123; var adder = function () &#123; var _args = []; var _adder = function _adder() &#123; [].push.apply(_args, [].slice.call(arguments)); return _adder; &#125;; _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder; &#125; return adder()(num);&#125;module.exports = plus; 运行一下,通过全部的测试用例，需要注意的是由于题目的要求运行在严格模式下，所以我们在_adder函数内部是不能引用arguments.callee，这时我们采用的方法是给函数表达式中函数本身起名_adder，这样就解决的这个问题。 希望大家能从中或多或少学到一些东西，入行资历甚浅，不足之处请多指教！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的迁移之路---[1]]]></title>
    <url>%2FES6%E7%9A%84%E8%BF%81%E7%A7%BB%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[前言 现在前端这个大环境，如果不会ES6还真算是落伍了。今天我就将一些常用的一些有关ES6的一些常用的语法糖，和新添加的一些特性一一列出来。 准备 往往使用ES6开发的前端应用都是要依赖babel这个工具包的(为什么使用babel呢！当然因为为了我们的项目更好的兼容)。至于bable是干什么的！大家可以点击这个!话不多说，接下来为大家es6为我们提供的一系列语法糖！ 块级作用域、let和const的用法 什么是块级作用域！ {}中就是一个块级作用域！ 我们可以用它替代我们的(fun)() es6以前我们什么一个变量，往往都是使用var。但是ES6中官方为我们推荐了let，const，两者到底有什么区别呢？ 12345678910function test()&#123; for(let i=1;i&lt;3;i++)&#123; console.log(i); &#125; console.log(i); let a = 2 ; a = 3; console.log(a)&#125;test() //1,2 3 从这个函数输出的情况可以看出，我们只输出了for循环中的变量。这里就可以看出let只能在同一个块级作用域才能有效声明。 同时我们的变量a也随这我们的改变改变了！ 1234567891011121314function first()&#123; const PI=3.1415926; PI = 3; console.log(PI);&#125;function last()&#123; const k=&#123; a:1 &#125; k.b=3; console.log(k);&#125;first()// 报错SyntaxError: &quot;PI&quot; is read-onlylast() //&#123;a:1,b:3&#125; 前者可以看出const声明出来的变量不能进行修改，否则就会报错。 后者就是正常的输出了我们想要的一个object。 使用 let 声明一个可以改变的变量，用 const 声明一个不能被重新赋值的变量。 结构赋值es6特有的语法糖，很好用。 123456789101112131415161718192021222324252627282930&#123; let a,b; [a,b]=[1,2]; console.log(a,b);//1,2&#125;&#123; let a,b; (&#123;a,b&#125;=&#123;a:1,b:2&#125;) console.log(a,b);//1,2&#125;&#123; function f()&#123; return [1,2] &#125; let a,b; [a,b]=f(); console.log(a,b);//1,1&#125;&#123; let metaData=&#123; title:&apos;abc&apos;, test:[&#123; title:&apos;test&apos;, desc:&apos;description&apos; &#125;] &#125; let &#123;title:esTitle,test:[&#123;title:cnTitle&#125;]&#125;=metaData; console.log(esTitle,cnTitle);//&apos;abc&apos;,&apos;test&apos;&#125; 这个三个块级作用域中是不同类型的结构赋值的声明方法，是不是特别神奇！大家直接用吧！最好我模拟了从后台拿接口的场景。各位可以跟着套用! RegExp的变化我从三个方面来剖析ES5-ES6的变化。 构造函数1234567891011&#123; // #构造函数# let regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;); //第一个参数是字符串，第二个是修饰符 let regex2 = new RegExp(/xyz/i); //第一个参数是正则表达式，不接受第二个参数，否则会报错 console.log(regex.test(&apos;xyz123&apos;), regex2.test(&apos;xyz123&apos;)); console.log(regex.test(&apos;xyZ123&apos;), regex2.test(&apos;xyZ123&apos;)); let regex3 = new RegExp(/abc/ig, &apos;i&apos;); console.log(regex3.flags); //原有正则对象的修饰符是ig，它会被第二个参数i覆盖&#125; 在ES5的时候regex3这种声明方法是会报错的因为，RegExp构造函数的参数是一个正则表达式的时候，ES5 不允许此时使用第二个参数添加修饰符！ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] 1234&#123; let regex = new RegExp(&apos;xyz&apos;, &apos;ig&apos;); console.log(regex.test(&apos;xyz0XYZ1xyz2&apos;), regex.exec(&apos;xyz0XYZ1xyz2&apos;));&#125; 修饰符1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; // y修饰符 let s = &apos;bbbb_bbb_bb_b&apos;; var a1 = /b+/g; var a2 = /b+/y; console.log(a1.exec(s), a2.exec(s)); // [&quot;bbbb&quot;],[&quot;bbbb&quot;] console.log(a1.exec(s), a2.exec(s)); // [&quot;bbb&quot;],null console.log(a1.sticky, a2.sticky); //表示是否开启了粘连模式&#125;&#123; console.log(&apos;u修饰符&apos;,/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)); // true console.log(&apos;u修饰符&apos;,/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)); // false // 大括号表示Unicode字符，只有加上u才能识别 console.log(/\u&#123;61&#125;/.test(&apos;a&apos;)); // false console.log(/\u&#123;61&#125;/u.test(&apos;a&apos;)); // true console.log(/\u&#123;20BB7&#125;/u.test(&apos;𠮷&apos;)); // true // 点（.）字符不能识别码点大于0xFFFF的Unicode字符，必须加上u修饰符。 let s = &apos;𠮷&apos;; console.log(&apos;大于0xFFFF的Unicode字符&apos;,/^.$/.test(s)); // false console.log(&apos;使用u字符&apos;,/^.$/u.test(s)); // true // 使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。 console.log(&apos;量词&apos;,/a&#123;2&#125;/.test(&apos;aa&apos;)); // true console.log(&apos;量词&apos;,/a&#123;2&#125;/u.test(&apos;aa&apos;)); // true console.log(&apos;量词&apos;,/𠮷&#123;2&#125;/.test(&apos;𠮷𠮷&apos;)); // false console.log(&apos;量词&apos;,/𠮷&#123;2&#125;/u.test(&apos;𠮷𠮷&apos;)); // true&#125;&#123; // #正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外 // U+000A 换行符（\n） // U+000D 回车符（\r） // U+2028 行分隔符（line separator） // U+2029 段分隔符（paragraph separator） // 只是一个提案目前还不支持 // let reg=/test.go/s; // console.log(reg.test(&apos;test\ngo&apos;)); // console.log(reg.test(&apos;test\ngo&apos;)); console.log(&apos;s变通方法&apos;,/foo.bar/.test(&apos;foo\nbar&apos;)); console.log(&apos;s变通方法&apos;,/foo[^]bar/.test(&apos;foo\nbar&apos;));&#125; 今天的分享就到这！喜欢的话记得star哟！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo踩过的一些坑]]></title>
    <url>%2F%E6%90%AD%E5%BB%BAhexo%E8%B8%A9%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[简介第一写blog，同时自己也会一直坚持写出一些能够帮助到大家的一些文章，话不多说直接进入正题。 准备本人的个人博客是放在github上的，所以GitHub的账号当然是必须得。 安装Node.js在官网下载，安装即可，我们用它生成静态网页 安装部署hexo Mac端的输入以下命令安装：sudo npm i -g hexo 如果觉得下载速度缓慢可以使用npm淘宝镜像：sudo npm i -g cnpm --registry=https://registry.npm.taobao.org Window端输入以下命令安装：npm i -g hexo Window端输入以下命令安装npm淘宝镜像：npm i -g cnpm --registry=https://registry.npm.taobao.org 部署hexo项目cnpm i hexo-cli -ghexo init blogcd blognpm installhexo server 关联Github 在github上新建个仓库，名为yourname.github.io,yourname是github的用户名，这个规则不能变.然后新建一对ssh的key,将公钥添加到github,添加SSH keys之后，就可以使用git为后缀的仓库地址，本地push的时候无需输入用户名和密码. 注意:考虑到大家不止一个github，此处如果不这样处理，使用https的仓库地址，再接下来部署时往往会出现不让输入github用户名和密码的问题! 安装好 hexo-deployer-git 插件,在到时部署到远程仓库要用到npm install hexo-deployer-git --save编辑本地hexo目录下的_config.yml文件,搜索deploy关键字，然后添加如下三行:deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 恭喜你成功搭建了你的个人blog发表文章 hexo publish [layout] &lt;article_name&gt; //如果有 _drafts 目录，就会自动将文章发表到 _posts 目录下 hexo generate //可简写为 hexo g 会将 source 目录中除了 _ 开头的目录或文件生成到 public 文件夹下. 部署站点 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 接下来是进阶版哟！图中各目录或文件大致介绍 Name Description node_modules 插件模块，包括Hexo相关的插件 public 公共资源目录，存放生成的站点文件 scaffolds 模板目录，可根据里面的文件生成文章 source 资源文件夹，存放发布文章或草稿 themes 主题文件夹 .gitignore 忽略部署的文件或目录 _config.yml 站点配置文件，可在里面设置站点的各种参数 db.json 数据依赖 packgae.json 版本依赖 NexT 主题使用cd hexo_home git clone https://github.com/iissan/hexo-theme-next themes-next //执行该命令将会将 next 主题克隆到 themes 目录下，原本该目录已经有了一个名为 landscape 的主题. 克隆完了后修改_config.yml 将主题修改为 next. 验证主题能否成功应用: hexo g hexo s -debug //执行完毕访问 localhost:4000 看是否正常, 否则根据 debug 信息看下哪里出错了。 主题设定 该主题有三种外观，分别是： Muse - 默认scheme,黑白主调，大量留白Mist – Muse的紧凑版本，整洁有序的单栏外观Pisces – 双栏 scheme ,小清新 搜索scheme关键字，切换scheme通过更改主题配置文件，就是 next 目录下的 _config.yml 文件。 语言设置 添加背景动画NexT已经自带了多种背景动画效果，你只需要根据需求在主题配置文件修改其中一个为true即可。 # Canvas-nest canvas_nest: false # three_waves three_waves: false # canvas_lines canvas_lines: false # canvas_sphere canvas_sphere: false # Only fit scheme Pisces # Canvas-ribbon canvas_ribbon: false 实现效果： 添加顶部加载条在主题配置文件中搜索pace： 12345678910111213141516171819# Progress bar in the top during page loading. 加载条 pace: true # Themes list: #pace-theme-big-counter #pace-theme-bounce #pace-theme-barber-shop #pace-theme-center-atom #pace-theme-center-circle #pace-theme-center-radar #pace-theme-center-simple #pace-theme-corner-indicator #pace-theme-fill-left #pace-theme-flash #pace-theme-loading-bar #pace-theme-mac-osx #pace-theme-minimal # For example # pace_theme: pace-theme-center-simple pace_theme: pace-theme-minimal 文章末尾统一添加“本文结束”标记修改/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 #换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #555;font-size:14px;&quot;&gt;-------------The End-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在这个位置添加代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件，在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag:enabled: true 实现效果： 修改作者头像并旋转打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 统计访客量以及文章阅读量NexT主题集成了不蒜子统计功能：123456789101112131415161718# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/# 不蒜子统计功能busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: false site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: false site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: false page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。当site_uv: true时，代表在页面底部显示站点的UV值。当site_pv: true时，代表在页面底部显示站点的PV值。当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。site_uv_header和site_uv_footer这几个为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。示例：12345678910111213enable: true# 效果：本站访客数12345人次site_uv: truesite_uv_header: 本站访客数site_uv_footer: 人次# 效果：本站总访问量12345次（一般不开启这个）site_pv: truesite_pv_header: 本站总访问量site_pv_footer: 次# 效果：本文总阅读量12345次page_pv: truepage_pv_header: 本文总阅读量page_pv_footer: 次 阅读次数统计（基于LeanCloud）相比不蒜子的统计，LeanCloud的文章阅读量统计更加稳定靠谱，所以本人也把网站的文章内统计改为LeanCloud的了。设置方法参考该文章–传送门 实现效果： 字数统计用于统计文章的字数以及分析出阅读时间。在主题配置文件中，搜索wordcount，设置为下面这样就可以了： 1234567# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true min2read: true wordcount: true separated_meta: true 再打开\themes\next\layout\_macro\post.swig文件，在leancloud-visitors-count后面位置添加一个分割符： 实现效果： 另外，在/themes/next/layout/_partials/footer.swig1文件endif %}前加上下面代码可以实现在站点底部统计全站字数 123&lt;div class=&quot;theme-info&quot;&gt; &lt;span class=&quot;post-count&quot;&gt;Total Words:&#123;&#123; totalcount(site) &#125;&#125;&lt;/span&gt;&lt;/div&gt; 实现效果：如果无法显示可能是hexo-wordcount插件没有安装，git bash在网站根目录安装一下就可以：1$ npm install hexo-wordcount --save 添加看板娘实现效果：用git bash在站点根目录执行如下代码：1$ npm install hexo-helper-live2d --save 在站点配置文件末尾添加代码：123456## 看板娘live2d: model: hijiki position: left bottom: -30 mobileShow: false #手机端不显示 需要怎样的任务模型需要下载预览地址模型地址:1npm install --save live2d-widget-model-xxx, 具体设置可以看官方介绍–传送门。 感谢观看！记得star一下我的GitHub哟！]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
