<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6的迁移之路---[1]]]></title>
    <url>%2FES6%E7%9A%84%E8%BF%81%E7%A7%BB%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[前言 现在前端这个大环境，如果不会ES6还真算是落伍了。今天我就将一些常用的一些有关ES6的一些常用的语法糖，和新添加的一些特性一一列出来。 准备 往往使用ES6开发的前端应用都是要依赖babel这个工具包的(为什么使用babel呢！当然因为为了我们的项目更好的兼容)。至于bable是干什么的！大家可以点击这个!话不多说，接下来为大家es6为我们提供的一系列语法糖！ 块级作用域、let和const的用法 什么是块级作用域！ {}中就是一个块级作用域！ 我们可以用它替代我们的(fun)() es6以前我们什么一个变量，往往都是使用var。但是ES6中官方为我们推荐了let，const，两者到底有什么区别呢？ 12345678910function test()&#123; for(let i=1;i&lt;3;i++)&#123; console.log(i); &#125; console.log(i); let a = 2 ; a = 3; console.log(a)&#125;test() //1,2 3 从这个函数输出的情况可以看出，我们只输出了for循环中的变量。这里就可以看出let只能在同一个块级作用域才能有效声明。 同时我们的变量a也随这我们的改变改变了！ 1234567891011121314function first()&#123; const PI=3.1415926; PI = 3; console.log(PI);&#125;function last()&#123; const k=&#123; a:1 &#125; k.b=3; console.log(k);&#125;first()// 报错SyntaxError: &quot;PI&quot; is read-onlylast() //&#123;a:1,b:3&#125; 前者可以看出const声明出来的变量不能进行修改，否则就会报错。 后者就是正常的输出了我们想要的一个object。 使用 let 声明一个可以改变的变量，用 const 声明一个不能被重新赋值的变量。 结构赋值es6特有的语法糖，很好用。 123456789101112131415161718192021222324252627282930&#123; let a,b; [a,b]=[1,2]; console.log(a,b);//1,2&#125;&#123; let a,b; (&#123;a,b&#125;=&#123;a:1,b:2&#125;) console.log(a,b);//1,2&#125;&#123; function f()&#123; return [1,2] &#125; let a,b; [a,b]=f(); console.log(a,b);//1,1&#125;&#123; let metaData=&#123; title:&apos;abc&apos;, test:[&#123; title:&apos;test&apos;, desc:&apos;description&apos; &#125;] &#125; let &#123;title:esTitle,test:[&#123;title:cnTitle&#125;]&#125;=metaData; console.log(esTitle,cnTitle);//&apos;abc&apos;,&apos;test&apos;&#125; 这个三个块级作用域中是不同类型的结构赋值的声明方法，是不是特别神奇！大家直接用吧！最好我模拟了从后台拿接口的场景。各位可以跟着套用! RegExp的变化我从三个方面来剖析ES5-ES6的变化。 构造函数1234567891011&#123; // #构造函数# let regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;); //第一个参数是字符串，第二个是修饰符 let regex2 = new RegExp(/xyz/i); //第一个参数是正则表达式，不接受第二个参数，否则会报错 console.log(regex.test(&apos;xyz123&apos;), regex2.test(&apos;xyz123&apos;)); console.log(regex.test(&apos;xyZ123&apos;), regex2.test(&apos;xyZ123&apos;)); let regex3 = new RegExp(/abc/ig, &apos;i&apos;); console.log(regex3.flags); //原有正则对象的修饰符是ig，它会被第二个参数i覆盖&#125; 在ES5的时候regex3这种声明方法是会报错的因为，RegExp构造函数的参数是一个正则表达式的时候，ES5 不允许此时使用第二个参数添加修饰符！ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] 1234&#123; let regex = new RegExp(&apos;xyz&apos;, &apos;ig&apos;); console.log(regex.test(&apos;xyz0XYZ1xyz2&apos;), regex.exec(&apos;xyz0XYZ1xyz2&apos;));&#125; 修饰符1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; // y修饰符 let s = &apos;bbbb_bbb_bb_b&apos;; var a1 = /b+/g; var a2 = /b+/y; console.log(a1.exec(s), a2.exec(s)); // [&quot;bbbb&quot;],[&quot;bbbb&quot;] console.log(a1.exec(s), a2.exec(s)); // [&quot;bbb&quot;],null console.log(a1.sticky, a2.sticky); //表示是否开启了粘连模式&#125;&#123; console.log(&apos;u修饰符&apos;,/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)); // true console.log(&apos;u修饰符&apos;,/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)); // false // 大括号表示Unicode字符，只有加上u才能识别 console.log(/\u&#123;61&#125;/.test(&apos;a&apos;)); // false console.log(/\u&#123;61&#125;/u.test(&apos;a&apos;)); // true console.log(/\u&#123;20BB7&#125;/u.test(&apos;𠮷&apos;)); // true // 点（.）字符不能识别码点大于0xFFFF的Unicode字符，必须加上u修饰符。 let s = &apos;𠮷&apos;; console.log(&apos;大于0xFFFF的Unicode字符&apos;,/^.$/.test(s)); // false console.log(&apos;使用u字符&apos;,/^.$/u.test(s)); // true // 使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。 console.log(&apos;量词&apos;,/a&#123;2&#125;/.test(&apos;aa&apos;)); // true console.log(&apos;量词&apos;,/a&#123;2&#125;/u.test(&apos;aa&apos;)); // true console.log(&apos;量词&apos;,/𠮷&#123;2&#125;/.test(&apos;𠮷𠮷&apos;)); // false console.log(&apos;量词&apos;,/𠮷&#123;2&#125;/u.test(&apos;𠮷𠮷&apos;)); // true&#125;&#123; // #正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外 // U+000A 换行符（\n） // U+000D 回车符（\r） // U+2028 行分隔符（line separator） // U+2029 段分隔符（paragraph separator） // 只是一个提案目前还不支持 // let reg=/test.go/s; // console.log(reg.test(&apos;test\ngo&apos;)); // console.log(reg.test(&apos;test\ngo&apos;)); console.log(&apos;s变通方法&apos;,/foo.bar/.test(&apos;foo\nbar&apos;)); console.log(&apos;s变通方法&apos;,/foo[^]bar/.test(&apos;foo\nbar&apos;));&#125; 今天的分享就到这！喜欢的话记得star哟！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo踩过的一些坑]]></title>
    <url>%2F%E6%90%AD%E5%BB%BAhexo%E8%B8%A9%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[简介第一写blog，同时自己也会一直坚持写出一些能够帮助到大家的一些文章，话不多说直接进入正题。 准备本人的个人博客是放在github上的，所以GitHub的账号当然是必须得。 安装Node.js在官网下载，安装即可，我们用它生成静态网页 安装部署hexo Mac端的输入以下命令安装：sudo npm i -g hexo 如果觉得下载速度缓慢可以使用npm淘宝镜像：sudo npm i -g cnpm --registry=https://registry.npm.taobao.org Window端输入以下命令安装：npm i -g hexo Window端输入以下命令安装npm淘宝镜像：npm i -g cnpm --registry=https://registry.npm.taobao.org 部署hexo项目cnpm i hexo-cli -ghexo init blogcd blognpm installhexo server 关联Github 在github上新建个仓库，名为yourname.github.io,yourname是github的用户名，这个规则不能变.然后新建一对ssh的key,将公钥添加到github,添加SSH keys之后，就可以使用git为后缀的仓库地址，本地push的时候无需输入用户名和密码. 注意:考虑到大家不止一个github，此处如果不这样处理，使用https的仓库地址，再接下来部署时往往会出现不让输入github用户名和密码的问题! 安装好 hexo-deployer-git 插件,在到时部署到远程仓库要用到npm install hexo-deployer-git --save编辑本地hexo目录下的_config.yml文件,搜索deploy关键字，然后添加如下三行:deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 恭喜你成功搭建了你的个人blog发表文章 hexo publish [layout] &lt;article_name&gt; //如果有 _drafts 目录，就会自动将文章发表到 _posts 目录下 hexo generate //可简写为 hexo g 会将 source 目录中除了 _ 开头的目录或文件生成到 public 文件夹下. 部署站点 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 接下来是进阶版哟！图中各目录或文件大致介绍 Name Description node_modules 插件模块，包括Hexo相关的插件 public 公共资源目录，存放生成的站点文件 scaffolds 模板目录，可根据里面的文件生成文章 source 资源文件夹，存放发布文章或草稿 themes 主题文件夹 .gitignore 忽略部署的文件或目录 _config.yml 站点配置文件，可在里面设置站点的各种参数 db.json 数据依赖 packgae.json 版本依赖 NexT 主题使用cd hexo_home git clone https://github.com/iissan/hexo-theme-next themes-next //执行该命令将会将 next 主题克隆到 themes 目录下，原本该目录已经有了一个名为 landscape 的主题. 克隆完了后修改_config.yml 将主题修改为 next. 验证主题能否成功应用: hexo g hexo s -debug //执行完毕访问 localhost:4000 看是否正常, 否则根据 debug 信息看下哪里出错了。 主题设定 该主题有三种外观，分别是： Muse - 默认scheme,黑白主调，大量留白Mist – Muse的紧凑版本，整洁有序的单栏外观Pisces – 双栏 scheme ,小清新 搜索scheme关键字，切换scheme通过更改主题配置文件，就是 next 目录下的 _config.yml 文件。 语言设置 添加背景动画NexT已经自带了多种背景动画效果，你只需要根据需求在主题配置文件修改其中一个为true即可。 # Canvas-nest canvas_nest: false # three_waves three_waves: false # canvas_lines canvas_lines: false # canvas_sphere canvas_sphere: false # Only fit scheme Pisces # Canvas-ribbon canvas_ribbon: false 实现效果： 添加顶部加载条在主题配置文件中搜索pace： 12345678910111213141516171819# Progress bar in the top during page loading. 加载条 pace: true # Themes list: #pace-theme-big-counter #pace-theme-bounce #pace-theme-barber-shop #pace-theme-center-atom #pace-theme-center-circle #pace-theme-center-radar #pace-theme-center-simple #pace-theme-corner-indicator #pace-theme-fill-left #pace-theme-flash #pace-theme-loading-bar #pace-theme-mac-osx #pace-theme-minimal # For example # pace_theme: pace-theme-center-simple pace_theme: pace-theme-minimal 文章末尾统一添加“本文结束”标记修改/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 #换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #555;font-size:14px;&quot;&gt;-------------The End-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在这个位置添加代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件，在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag:enabled: true 实现效果： 修改作者头像并旋转打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 统计访客量以及文章阅读量NexT主题集成了不蒜子统计功能：123456789101112131415161718# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/# 不蒜子统计功能busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: false site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: false site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: false page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。当site_uv: true时，代表在页面底部显示站点的UV值。当site_pv: true时，代表在页面底部显示站点的PV值。当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。site_uv_header和site_uv_footer这几个为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。示例：12345678910111213enable: true# 效果：本站访客数12345人次site_uv: truesite_uv_header: 本站访客数site_uv_footer: 人次# 效果：本站总访问量12345次（一般不开启这个）site_pv: truesite_pv_header: 本站总访问量site_pv_footer: 次# 效果：本文总阅读量12345次page_pv: truepage_pv_header: 本文总阅读量page_pv_footer: 次 阅读次数统计（基于LeanCloud）相比不蒜子的统计，LeanCloud的文章阅读量统计更加稳定靠谱，所以本人也把网站的文章内统计改为LeanCloud的了。设置方法参考该文章–传送门 实现效果： 字数统计用于统计文章的字数以及分析出阅读时间。在主题配置文件中，搜索wordcount，设置为下面这样就可以了： 1234567# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true min2read: true wordcount: true separated_meta: true 再打开\themes\next\layout\_macro\post.swig文件，在leancloud-visitors-count后面位置添加一个分割符： 实现效果： 另外，在/themes/next/layout/_partials/footer.swig1文件endif %}前加上下面代码可以实现在站点底部统计全站字数 123&lt;div class=&quot;theme-info&quot;&gt; &lt;span class=&quot;post-count&quot;&gt;Total Words:&#123;&#123; totalcount(site) &#125;&#125;&lt;/span&gt;&lt;/div&gt; 实现效果：如果无法显示可能是hexo-wordcount插件没有安装，git bash在网站根目录安装一下就可以：1$ npm install hexo-wordcount --save 添加看板娘实现效果：用git bash在站点根目录执行如下代码：1$ npm install hexo-helper-live2d --save 在站点配置文件末尾添加代码：123456## 看板娘live2d: model: hijiki position: left bottom: -30 mobileShow: false #手机端不显示 需要怎样的任务模型需要下载预览地址模型地址:1npm install --save live2d-widget-model-xxx, 具体设置可以看官方介绍–传送门。 感谢观看！记得star一下我的GitHub哟！]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
